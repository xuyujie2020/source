---
title: 多线程编程
---

## 进程与线程的区别

- 进程是操作系统资源分配最小单元，拥有自己的堆，栈，等内存空间，线程是运算调度最小单元，线程会共享这些内存空间
- 线程属于进程
- 创建，销毁，调度，线程比进程有优势
- 子进程无法影响父进程，而子线程可以影响父线程，如果主线程发生异常会影响其所在进程和子线程。

## 线程间通信

信号，互斥锁，读写锁，条件变量，信号量

线程间共享同一块内存（堆，全局）只需要将数据复制到共享变量中即可通信。

互斥锁：只允许锁被占用的线程使用cpu资源

条件变量：条件变量始终与互斥锁一起使用，某个特定的条件为真时为止

信号量：实际上是一个非负的整数计数器，用来对公共资源控制，某个公共资源增加时，信号量就增加。

## 进程间通信

管道，消息队列，共享内存，信号量，信号，socket



## 死锁产生的原因

争夺共享资源，互相等待，互斥条件，请求和保持条件，环路等；

两个以上的进程争夺共享资源相互等待的现象

必要条件：互斥条件，必须有进程需要用到该资源，并出现等待的情况

请求和保持条件，一个进程拥有一个资源未释放，还去申请新的资源，此时如果有其他进程正在使用，则会进行等待

不剥夺条件：进程以获得的资源，未使用完不能被剥夺

环路等地啊条件，

### 解决死锁的方法

银行家算法：

判断所需资源是否会大于资源总量，若资源足够，则会判断资源分配之后会不会造成系统的不安全，只有安全才会分配资源



## C++11stl多线程

https://blog.csdn.net/lht501692913/article/details/89512597?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166562749216782391872467%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166562749216782391872467&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-89512597-null-null.142^v53^new_blog_pos_by_title,201^v3^control&utm_term=stl%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187

多线程的创建与使用，

```c++
#include <thread>

void fun1()
{
    ...
}
void Demo::fun2()
{
    ...
}

int main()
{	
    fun1();
    std::thread pid(&Demo::fun2,this);
}
```



# 无锁编程

## 无锁队列

